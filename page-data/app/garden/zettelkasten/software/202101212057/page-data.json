{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/app/garden/zettelkasten/software/202101212057","result":{"data":{"file":{"childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"treatise-of-state\"\n  }, \"Treatise of State\"), mdx(\"p\", null, \"#frontend\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"local (component) : State that belongs to a single component. Can also be thought about as UI state. UI state can be extracted from a presentation component into a React hook.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"shared (global) : As soon as some state belongs to more than one component, it's shared global state. Components shouldn't need to know about each other (a header shouldn't need to know about a todo).\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"remote (global) : The state that exists behind APIs in services. When we make queries for remote state, we hold onto a local copy of it accessible from a global scope.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"meta : Meta state refers to state about state. The best example of this is the loading async states that tell us the progress of our network requests.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"router state: The current URL of the browser.\")));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[],"inboundReferences":[{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"ui-logic\"\n  }, \"UI Logic\"), mdx(\"p\", null, \"#architecture\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"View Behavior & local component state\")), mdx(\"p\", null, \"In this layer, we have logic for the view. Render a view by certain condition. If logged in render this, otherwise render that.\"), mdx(\"p\", null, \"In this layer we can have local component state [\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Foam/dbe51f8c256fb5f2fa5a3358940b9961/202101212057.md\",\n    \"title\": \"Treatise of State\"\n  }, \"202101212057\"), \"] that only belong to single component. It can be extracted with react hooks\"), mdx(\"p\", null, \"Use integration test in this layer. No need to unit test because we can gain more confidence with integration test\"), mdx(\"p\", null, \"example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"import React, { Component } from 'react'\\nimport PropTypes from 'prop-types'\\nimport classnames from 'classnames'\\nimport TodoTextInput from './TodoTextInput'\\nimport { useState } from 'react'\\n\\n/**\\n * Decompose the UI logic from the presentational component\\n * and store it in a React hook.\\n *\\n * All data and operations in this hook are UI logic for the\\n * component - we've just separated concerns, that's all.\\n */\\n\\nfunction useTodoComponent (actions) {\\n  // \\\"editing\\\" is a form of local (component) state\\n  const [editing, setEditing] = useState(false);\\n\\n  const handleSave = (id: number, text: string) => {\\n    if (text.length === 0) {\\n      actions.deleteTodo(id)\\n    } else {\\n      actions.editTodo(id, text)\\n    }\\n    setEditing(true);\\n  }\\n\\n  const handleDoubleClick = () => {\\n    setEditing(true);\\n  }\\n\\n  return { \\n    models: { editing }, \\n    operations: { handleSave, handleDoubleClick } \\n  }\\n}\\n\\n/**\\n * This component relies on some local state, but none of \\n * it lives within the component, which is purely \\n * presentational.\\n */\\n\\nexport function Todo (props) {\\n  const { todo, actions } = props;\\n  \\n  // Grab our local (component) state and access to other UI logic\\n  const { models, operations } = useTodoComponent(actions);\\n  \\n  // Conditional UI logic\\n  return models.editing ? (\\n    <TodoTextInput \\n      text={todo.text}\\n      editing={models.editing}\\n      onSave={(text: string) => operations.handleSave(todo.id, text)} />\\n  ) : (\\n    <div className=\\\"view\\\">\\n      <input \\n        className=\\\"toggle\\\"\\n        type=\\\"checkbox\\\"\\n        checked={todo.completed}\\n        onChange={() => actions.completeTodo(todo.id)} />\\n      <label onDoubleClick={operations.handleDoubleClick}>\\n        {todo.text}\\n      </label>\\n      <button \\n        className=\\\"destroy\\\"\\n        onClick={() => actions.deleteTodo(todo.id)} />\\n    </div>\\n  )\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"f1804c8b-8b82-5be1-91ce-617612db0f12","fields":{"slug":"/app/garden/zettelkasten/software/202101212051","title":"UI Logic"}}}]},"fields":{"slug":"/app/garden/zettelkasten/software/202101212057","title":"Treatise of State"}}},"pageContext":{"id":"85590e88-04ef-5f55-995e-a6652e85c7e1"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}